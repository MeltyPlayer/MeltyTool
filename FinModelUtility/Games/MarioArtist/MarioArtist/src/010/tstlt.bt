//------------------------------------------------
//--- 010 Editor v15.0.1 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

BigEndian();

local uint COLOR_IMAGE = 0x0000ff;
local uint COLOR_COUNT = 0x00ff00;
local uint COLOR_OFFSET = 0xff0000;
local uint COLOR_HEADER = 0xffffff;
local uint COLOR_INDEX = 0x00ffff;
local uint COLOR_SECTION0 = 0xffff00;
local uint COLOR_SECTION1 = 0xff00ff;
local uint COLOR_SECTION2 = 0x880088;

short thumbnail[24 * 24] <bgcolor=COLOR_IMAGE>;

uint CeilAlign(uint x, uint align) {
  local float fraction = (x / (1. * align));
  return Ceil(fraction) * align;  
}

typedef struct {
  ubyte r;
  ubyte g;
  ubyte b;
  ubyte a;
  
  local uint color=(((uint) b) << 16) | (((uint) g) << 8) | r;
  
  FSeek(FTell() - 4);
  uint rgba <bgcolor=color>;
} Rgba32;

typedef struct {
  ubyte l;
  
  local uint color=(((uint) l) << 16) | (((uint) l) << 8) | l;
  
  FSeek(FTell() - 1);
  byte pixel <bgcolor=color>;
} L8;

typedef struct L8Image(int size) {
  L8 pixels[size];
};

typedef struct {
  uint checksum;
  uint unk1;
  uint magic[2];
  
  uint unk2;
  uint fileSize <bgcolor=COLOR_COUNT>;
  uint unk3;
  uint headSectionLength; // Starts at 0x16770

  uint bodySectionLength; // Starts immediately after headSection
  uint unk6;
  uint unk7;
  uint unk8;
} Header <bgcolor=COLOR_HEADER>;

Header header;

local uint headOffset = 0x16770;
local uint bodyOffset = headOffset + header.headSectionLength;
local uint thirdOffset = headOffset + header.unk3;

short faceImages[128 * 141] <bgcolor=COLOR_IMAGE>;

typedef struct {
  uint sometimesJointCount <bgcolor=COLOR_COUNT>;
  uint unkCount1 <bgcolor=COLOR_COUNT>;
  
  uint unk2; 
  Rgba32 skinColor;
} AnotherHeader;
AnotherHeader anotherHeader;

typedef struct {
  uint unk1[4];
  float unk0[6];
} UnkSection0 <bgcolor=COLOR_HEADER>;
UnkSection0 unkSection0s[9] <optimize=false>;

// - These store x/y coordinates
// - Probably are a bunch of expressions right in a row
FSeek(0x9340);
float expressionPins[0x57D];

FSeek(0xa934);
typedef struct {
  ushort unk0;
  ushort unk1;

  ushort unkIndex0;
  ushort unk2;
  ushort unk3;
  ushort unk4;
  
  ushort unk5;
  ushort unk6;
  ushort unk7;
  
  byte previousIndex;
  byte nextIndex;
    
  float matrix[4 * 4];
    
  byte unk8[12];
} Joint <bgcolor=COLOR_HEADER>;
Joint joints[0x1F] <optimize=false>;

/*FSeek(0xB4A8);
typedef struct {
  byte unk0[0x50];
} UnkSection4 <bgcolor=COLOR_HEADER>;
UnkSection4 unkSection4s[0x35] <optimize=false>;*/

FSeek(0xB6B8);
L8Image someImage(16 * 24);

// These seem like they might all be different sizes...
/*FSeek(0xB8D0);
typedef struct {
  ushort someIndex0;
  ushort someIndex1;
  uint chosenModelIndex;
  uint chosenColorIndex; 
  Rgba32 color;
  uint unk;
} ChosenPart <bgcolor=COLOR_HEADER>;
ChosenPart chosenParts[0x30] <optimize=false>;*/

typedef struct {
  uint unk0[2];

  uint chosenColorIndex0 <bgcolor=COLOR_INDEX>; 
  Rgba32 chosenColor0;

  uint chosenColorIndex1 <bgcolor=COLOR_INDEX>; 
  Rgba32 chosenColor1;

  uint unk1[2];
  uint address0 <bgcolor=COLOR_OFFSET>;

  uint unk2[3];
  uint address1 <bgcolor=COLOR_OFFSET>;
  
  uint unk3[3];
  uint address1 <bgcolor=COLOR_OFFSET>;

  uint unk4;
} ChosenPart1 <bgcolor=COLOR_HEADER>;

typedef struct {
  byte unk0[0x50];
} UnkSection5 <bgcolor=COLOR_HEADER>;

FSeek(0xB840);
ChosenPart1 chosenParts1[5] <optimize=false>;

FSeek(0xBD08);
ChosenPart1 chosenParts1[8] <optimize=false>;

UnkSection5 unkSection5s[19];

FSeek(0xc538);
float unkFloats1[0x5A];

typedef struct {
  uint unk0[3];
  byte unk1[0x6c];
  float unk2[13];
  uint unk3[3];
} UnkSection2 <bgcolor=COLOR_HEADER>;

FSeek(0xc6c8);
uint headUnkSection2Count <bgcolor=COLOR_COUNT>;
UnkSection2 headUnkSection2s[headUnkSection2Count];

FSeek(0xeb00);
uint bodyUnkSection2Count <bgcolor=COLOR_COUNT>;
UnkSection2 bodyUnkSection2s[bodyUnkSection2Count];

// contains RAM addresses that point to display lists
FSeek(0xf968);
typedef struct {
  byte unk0[0xa8];
} UnkSection3 <bgcolor=COLOR_HEADER>;
//UnkSection3 unkSection3s[0x4c] <optimize=false>;

typedef struct {
  local uint baseOffset = FTell();
    
  ubyte unkByte0[4];
  uint totalSize <bgcolor=COLOR_COUNT>;

  uint imageSectionSize <bgcolor=COLOR_COUNT>;
  uint vertexSectionSize <bgcolor=COLOR_COUNT>;
  uint opcodeSectionSize <bgcolor=COLOR_COUNT>;
  uint section2Size <bgcolor=COLOR_COUNT>;
   
  ubyte unkByte1[4 * 1];
  
  uint imageSectionOffset <bgcolor=COLOR_OFFSET>;
  uint vertexSectionOffset <bgcolor=COLOR_OFFSET>;
  uint opcodeSectionOffset <bgcolor=COLOR_OFFSET>;
  uint section2Offset <bgcolor=COLOR_OFFSET>;

  ubyte unkByte2[4 * 3];
  
  ushort imageCount <bgcolor=COLOR_COUNT>;
  ushort vertexCount <bgcolor=COLOR_COUNT>;
  ushort unkCount <bgcolor=COLOR_COUNT>;
  ushort triangleCount <bgcolor=COLOR_COUNT>;
  
  short unk2[6];

  ubyte unkByte4[4 * 5];
  
  byte imageSectionData[imageSectionSize] <bgcolor=COLOR_IMAGE>;
  
  uint vertices[4 * vertexCount] <bgcolor=COLOR_SECTION0>;

  // The bulk of the logic is here...
  // - Fast3DEX2 opcodes
  // - Handles vertex setup by loading from a specific address (relative to 0x16770)
  //   - Vertices can be fetched from other meshes...
  // - Handles texture setup (width/format/clamp are defined here)
  byte opcodeSectionData[opcodeSectionSize] <bgcolor=COLOR_SECTION1>;

  // No idea what this is, but its size seems to always be a multiple of 0xc.
  byte unkValue2s[section2Size] <bgcolor=COLOR_SECTION2>;
  
  FSeek(baseOffset + CeilAlign(totalSize, 0x10));
} Mesh <bgcolor=COLOR_HEADER>;

{
    typedef struct (uint baseOffset) {
      uint meshSegmentedAddress <bgcolor=COLOR_OFFSET>;
      
      local uint meshOffset = (meshSegmentedAddress & 0xffffff) + baseOffset;
      local uint tempOffset = FTell();
      FSeek(meshOffset);
      Mesh mesh;
      FSeek(tempOffset);
      
      uint unk0[3];
      uint unk1[5];
      float unk2[6];
      
      uint unk3[0x1B];
    } MeshDefinition <bgcolor=COLOR_HEADER>;
    
    FSeek(0xda70);
    MeshDefinition headMeshDefinition(headOffset);

    FSeek(0xe4f0);
    MeshDefinition headMeshDefinition(headOffset);

    FSeek(0xf968);
    MeshDefinition bodyMeshDefinition(bodyOffset);
    
    FSeek(0xfc08);
    MeshDefinition bodyMeshDefinition(bodyOffset);
    
    FSeek(0xfea8);
    MeshDefinition bodyMeshDefinition(bodyOffset);

    FSeek(0x10e68);
    MeshDefinition bodyMeshDefinition(bodyOffset);

    FSeek(0x11108);
    MeshDefinition bodyMeshDefinition(bodyOffset);

    FSeek(0x11b88);
    MeshDefinition bodyMeshDefinition(bodyOffset);

    FSeek(0x11e28);
    MeshDefinition bodyMeshDefinition(bodyOffset);
    
    FSeek(0x120c8);
    MeshDefinition bodyMeshDefinition(bodyOffset);

    FSeek(0x12368);
    MeshDefinition bodyMeshDefinition(bodyOffset);

    FSeek(0x12608);
    MeshDefinition bodyMeshDefinition(bodyOffset);
}


FSeek(0x16680);
typedef struct {
  char name[21];
  char job[21];
  
  ushort gender;
  
  byte birthMonth;
  byte birthDay;
  ushort age;
  
  char catchphrase[21];

  char descriptionLine0[41];
  char descriptionLine1[41];
  char descriptionLine2[41];
  char descriptionLine3[41];
} Bio;
Bio bio;

typedef struct (int imageCount) { 
  short images[32 * 32 * imageCount] <bgcolor=COLOR_IMAGE>;
  
  Mesh mesh[3] <optimize=false>;
} MeshGroup;

FSeek(0x36040);
Mesh mesh;

FSeek(0x1e6b0);
Mesh hmmmMesh;

FSeek(headOffset);
MeshGroup headMeshGroup(8);

FSeek(bodyOffset);
MeshGroup bodyMeshGroup(16);