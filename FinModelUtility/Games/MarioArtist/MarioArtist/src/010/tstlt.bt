//------------------------------------------------
//--- 010 Editor v15.0.1 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

BigEndian();

local uint COLOR_IMAGE = 0x0000ff;
local uint COLOR_COUNT = 0x00ff00;
local uint COLOR_OFFSET = 0xff0000;
local uint COLOR_ORIENTATION = 0x888800;
local uint COLOR_HEADER = 0xffffff;
local uint COLOR_INDEX = 0x00ffff;
local uint COLOR_SECTION0 = 0xffff00;
local uint COLOR_SECTION1 = 0xff00ff;
local uint COLOR_SECTION2 = 0x880088;

short thumbnail[24 * 24] <bgcolor=COLOR_IMAGE>;

uint CeilAlign(uint x, uint align) {
    local float fraction = (x / (1. * align));
    return Ceil(fraction) * align;  
}

typedef struct {
    ubyte r;
    ubyte g;
    ubyte b;
    ubyte a;
    
    local uint color=(((uint) b) << 16) | (((uint) g) << 8) | r;
    
    FSeek(FTell() - 4);
    uint rgba <bgcolor=color>;
} Rgba32;

typedef struct {
    ubyte l;
    
    local uint color=(((uint) l) << 16) | (((uint) l) << 8) | l;
    
    FSeek(FTell() - 1);
    byte pixel <bgcolor=color>;
} L8;

typedef struct L8Image(int size) {
    L8 pixels[size] <optimize=false>;
};

typedef struct {
    uint checksum;
    uint unk1;
    uint magic[2];
    
    uint unk2;
    uint fileSize <bgcolor=COLOR_COUNT>;
    uint unk3;
    uint headSectionLength; // Starts at 0x16770
    
    uint bodySectionLength; // Starts immediately after headSection
    uint unk6;
    uint unk7;
    uint unk8;
} Header <bgcolor=COLOR_HEADER>;

Header header;

local uint headOffset = 0x16770;
local uint bodyOffset = headOffset + header.headSectionLength;
local uint thirdOffset = headOffset + header.unk3;

typedef struct {
  float x;
  float y;
} Vec2f;

typedef struct {
  uint x;
  uint y;
} Vec2i;

typedef struct {
  float x;
  float y;
  float z;
} Vec3f;

typedef struct {
    short faceImages[128 * 141] <bgcolor=COLOR_IMAGE>;
    
    Vec2i nosePosition <bgcolor=COLOR_ORIENTATION>;
    uint unk0;
    Rgba32 skinColor;
    
    typedef struct {
        typedef struct {
            ushort isLeft;
    
            enum <ushort> InclusionType { 
                IS_OMITTED = 0,
                IS_PRESENT = 3
            } inclusionType;    
      
            uint unk0[2];
            
            uint selectedImage <bgcolor=COLOR_INDEX>;
    
            Vec2f position <bgcolor=COLOR_ORIENTATION>;
            float unk1;
            Vec2f scale <bgcolor=COLOR_ORIENTATION>;
            float rotationDegrees <bgcolor=COLOR_ORIENTATION>;
        } ChosenFacePart;
        
        ChosenFacePart chosenFacePart;
        
        ChosenFacePart leftEye;
        ChosenFacePart rightEye;
        
        ChosenFacePart leftEyeBrow;
        ChosenFacePart rightEyeBrow;
        
        ChosenFacePart mouth;
        
        ChosenFacePart chosenFacePart[3] <optimize=false>;
    } ChosenFaceParts;   
    ChosenFaceParts chosenFaceParts;
        
    Vec3f unkVec3;
    
    Vec2i nosePosition <bgcolor=COLOR_ORIENTATION>;
    
    Rgba32 skinColor;
    uint unk1;
    
    typedef struct {   
      // Sorted in terms of columns rather than rows, i.e. first column, then second column, etc.
      Vec2f pins[13 * 9] <bgcolor=COLOR_ORIENTATION>;
    } Expression;
    Expression expressions[6];
} FaceHeader <bgcolor=COLOR_HEADER>;
FaceHeader faceHeader;

FSeek(0xa934);
typedef struct {
  ushort unk0;
  ushort unk1;

  ushort maybeMeshIndex;
  ushort unk2;
  ushort unk3;
  ushort unk4;
  
  byte index <bgcolor=COLOR_INDEX>;
  byte isLeft;
  ushort unk6;
  ushort unk7;
  
  byte previousIndex <bgcolor=COLOR_INDEX>;
  byte nextIndex <bgcolor=COLOR_INDEX>;
    
  float matrix[4 * 4] <bgcolor=COLOR_ORIENTATION>;
    
  byte unk8[12];
} Joint <bgcolor=COLOR_HEADER>;
Joint joints[0x1F] <optimize=false>;

/*FSeek(0xB4A8);
typedef struct {
  byte unk0[0x50];
} UnkSection4 <bgcolor=COLOR_HEADER>;
UnkSection4 unkSection4s[0x35] <optimize=false>;*/

// These seem like they might all be different sizes...
/*FSeek(0xB8D0);
typedef struct {
  ushort someIndex0;
  ushort someIndex1;
  uint chosenModelIndex;
  uint chosenColorIndex; 
  Rgba32 color;
  uint unk;
} ChosenPart <bgcolor=COLOR_HEADER>;
ChosenPart chosenParts[0x30] <optimize=false>;*/

typedef struct {
  uint chosenColorIndex <bgcolor=COLOR_INDEX>; 
  Rgba32 chosenColor;
} ChosenColor <bgcolor=COLOR_HEADER>;

typedef struct {
  uint unk0[2];

  ChosenColor chosenColor0;
  ChosenColor chosenColor1;

  uint unk1[2];
  uint address0 <bgcolor=COLOR_OFFSET>;

  uint unk2[3];
  uint address1 <bgcolor=COLOR_OFFSET>;
  
  uint unk3[3];
  uint address1 <bgcolor=COLOR_OFFSET>;

  uint unk4;
} ChosenPart1 <bgcolor=COLOR_HEADER>;

typedef struct {
    // These addresses are apart by 0x2A0, seem to point towards UnkSection3
    uint someAddress;
    
    byte unk0[0x4C];
} UnkSection5 <bgcolor=COLOR_HEADER>;

FSeek(0xB840);
ChosenPart1 headChosenParts1[5] <optimize=false>;

UnkSection5 headUnkSection5s[8] <optimize=false>;

FSeek(0xBD08);
ChosenPart1 bodyChosenParts1[8] <optimize=false>;

UnkSection5 bodyUnkSection5s[0x13] <optimize=false>;

FSeek(0xc538);
float unkFloats1[0x5A];

Rgba32 unkColor0;
Rgba32 skinColor;

typedef struct {
  uint unk0[3];
  uint unk1;
  uint unkSegmentedAddresses[5] <bgcolor=COLOR_OFFSET>;  
  byte unk2[0x54];

  Vec3f unkVec3a <bgcolor=COLOR_ORIENTATION>;
  Vec3f unkVec3b <bgcolor=COLOR_ORIENTATION>;

  uint unk3;

  Vec3f unkVec3c <bgcolor=COLOR_ORIENTATION>;
  Vec3f unkVec3d <bgcolor=COLOR_ORIENTATION>;

  uint unk4[3];
} UnkSection2 <bgcolor=COLOR_HEADER>;

FSeek(0xc6c8);
uint headUnkSection2Count <bgcolor=COLOR_COUNT>;
UnkSection2 headUnkSection2s[headUnkSection2Count] <optimize=false>;

FSeek(0xeae0);
typedef struct {
    Vec2i nosePosition;
    
    uint dlSegmentedAddresses[6] <bgcolor=COLOR_OFFSET>;
} NoseHeader <bgcolor=COLOR_HEADER>;
NoseHeader noseHeader;

FSeek(0xeb00);
uint bodyUnkSection2Count <bgcolor=COLOR_COUNT>;
UnkSection2 bodyUnkSection2s[bodyUnkSection2Count] <optimize=false>;

// contains RAM addresses that point to display lists
FSeek(0xf968);
typedef struct {
  byte unk0[0xa8];
} UnkSection3 <bgcolor=COLOR_HEADER>;
//UnkSection3 unkSection3s[0x4c] <optimize=false>;

typedef struct {
  local uint baseOffset = FTell();
    
  ubyte unkByte0[4];
  uint totalSize <bgcolor=COLOR_COUNT>;

  uint imageSectionSize <bgcolor=COLOR_COUNT>;
  uint vertexSectionSize <bgcolor=COLOR_COUNT>;
  uint opcodeSectionSize <bgcolor=COLOR_COUNT>;
  uint section2Size <bgcolor=COLOR_COUNT>;
   
  ubyte unkByte1[4 * 1];
  
  uint imageSectionOffset <bgcolor=COLOR_OFFSET>;
  uint vertexSectionOffset <bgcolor=COLOR_OFFSET>;
  uint opcodeSectionOffset <bgcolor=COLOR_OFFSET>;
  uint section2Offset <bgcolor=COLOR_OFFSET>;

  ubyte unkByte2[4 * 3];
  
  ushort imageCount <bgcolor=COLOR_COUNT>;
  ushort vertexCount <bgcolor=COLOR_COUNT>;
  ushort unkCount <bgcolor=COLOR_COUNT>;
  ushort triangleCount <bgcolor=COLOR_COUNT>;
  
  short unk2[6];

  ubyte unkByte4[4 * 5];
  
  byte imageSectionData[imageSectionSize] <bgcolor=COLOR_IMAGE>;
  
  uint vertices[4 * vertexCount] <bgcolor=COLOR_SECTION0>;

  // The bulk of the logic is here...
  // - Fast3DEX2 opcodes
  // - Handles vertex setup by loading from a specific address (relative to 0x16770)
  //   - Vertices can be fetched from other meshes...
  // - Handles texture setup (width/format/clamp are defined here)
  byte opcodeSectionData[opcodeSectionSize] <bgcolor=COLOR_SECTION1>;

  // No idea what this is, but its size seems to always be a multiple of 0xc.
  byte unkValue2s[section2Size] <bgcolor=COLOR_SECTION2>;
  
  FSeek(baseOffset + CeilAlign(totalSize, 0x10));
} Mesh <bgcolor=COLOR_HEADER>;

{
    typedef struct (uint baseOffset) {
      uint meshSegmentedAddresses[4] <bgcolor=COLOR_OFFSET>;
      
      local uint firstMeshSegmentedAddress = meshSegmentedAddresses[0];
      if (firstMeshSegmentedAddress != 0) {
          local uint meshOffset = (firstMeshSegmentedAddress & 0xffffff) + baseOffset;
          if (meshOffset < FileSize()) {
              local uint tempOffset = FTell();
              FSeek(meshOffset);
              uint firstMeshUint;
              if (firstMeshUint == 0) {
                  FSeek(meshOffset);
                  Mesh mesh;
              }
              FSeek(tempOffset);          
          }
      }
      
      uint unk1[5];
      float unk2[6];
      
      uint unk3;

      uint primitiveDl <bgcolor=COLOR_OFFSET>;
      uint unk4[0xC];
      
      uint vertexDl <bgcolor=COLOR_OFFSET>;
      uint unk5[0xC];
    } MeshDefinition <bgcolor=COLOR_HEADER>;
    
    FSeek(0xd530);
    MeshDefinition headMeshDefinition(headOffset)[0x20] <optimize=false>;

    FSeek(0xf968);
    MeshDefinition bodyMeshDefinitions(bodyOffset)[0x4C] <optimize=false>;
}


FSeek(0x16680);
typedef struct {
  char name[21];
  char job[21];
  
  ushort gender;
  
  byte birthMonth;
  byte birthDay;
  ushort age;
  
  char catchphrase[21];

  char descriptionLine0[41];
  char descriptionLine1[41];
  char descriptionLine2[41];
  char descriptionLine3[41];
} Bio;
Bio bio;

typedef struct (int imageCount) { 
  short images[32 * 32 * imageCount] <bgcolor=COLOR_IMAGE>;
  
  Mesh mesh[3] <optimize=false>;
} MeshGroup;

FSeek(0x36040);
Mesh mesh;

FSeek(0x1e6b0);
Mesh hmmmMesh;

FSeek(headOffset);
MeshGroup headMeshGroup(8);

FSeek(bodyOffset);
MeshGroup bodyMeshGroup(16);